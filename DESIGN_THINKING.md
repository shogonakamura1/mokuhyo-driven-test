# 設計思考の流れ

## 1. アーキテクチャ全体像の決定

### 1.1 技術スタックの選定理由
- **Next.js (App Router)**: サーバーコンポーネントとクライアントコンポーネントの分離が明確で、認証フローを実装しやすい
- **Go + Gin**: 軽量で高速、JWT検証などの認証処理をシンプルに実装できる
- **Supabase**: 認証とDBを一元管理でき、RLSでセキュリティを担保しやすい

### 1.2 プロジェクト構造の設計方針
```
goal-tree/
├── apps/
│   ├── web/          # Next.jsフロントエンド
│   └── api/          # Goバックエンド
├── supabase/
│   └── migrations/   # DBスキーマ管理
└── packages/         # 共有型定義（将来拡張用）
```

**理由**:
- モノレポ構成で、フロントとAPIを同じリポジトリで管理
- Supabaseマイグレーションを独立して管理
- 型定義の共有は将来的な拡張を見据えて配置

## 2. データベース設計の思考

### 2.1 テーブル設計のポイント
- **projects**: ユーザーごとの目標を管理
- **nodes**: ノートの各項目（木構造のノード）
- **edges**: 親子関係と順序を管理（1つの子は1つの親のみ）
- **user_settings**: ユーザー設定（テーマ等）

### 2.2 RLS（Row Level Security）の設計
- すべてのテーブルでRLSを有効化
- `auth.uid()` と `user_id` の一致でアクセス制御
- `nodes` と `edges` は `projects` 経由で所有権をチェック

### 2.3 論理削除の設計
- `deleted_at` カラムで論理削除を実現
- 子孫ノードの削除は `WITH RECURSIVE` で再帰的に処理
- クエリ時は `deleted_at IS NULL` でフィルタリング

## 3. API設計の思考

### 3.1 エンドポイント設計の原則
- RESTfulな設計を基本とする
- リソースベースのURL設計（`/projects/{id}/nodes`）
- HTTPメソッドで操作を表現（GET/POST/PATCH/DELETE）

### 3.2 認証フローの設計
1. フロントエンドでSupabase AuthでGoogleログイン
2. アクセストークンを取得
3. APIリクエスト時に `Authorization: Bearer {token}` ヘッダーで送信
4. Go APIでJWT検証（Supabase JWKSを使用）

### 3.3 トランザクション設計
- ノード作成時は `nodes` と `edges` を同一トランザクションで作成
- 並び替え（reorder）もトランザクションで一括更新

### 3.4 エラーハンドリング
- 400: バリデーションエラー
- 401: 認証エラー
- 403: 権限エラー（他人のプロジェクトへのアクセス）
- 500: サーバーエラー

## 4. フロントエンド設計の思考

### 4.1 ルーティング設計
- `/`: ランディングページ
- `/login`: ログインページ（認証済みならリダイレクト）
- `/input`: 目標入力ページ（認証必須）
- `/p/[projectId]`: メイン編集画面（認証必須）

### 4.2 状態管理の設計
- グローバル状態: Supabaseセッション、現在のプロジェクトID
- ローカル状態: ノード選択、編集状態、ツリー構造
- MVPでは `useState` + `useContext` で十分（Zustandは将来拡張用）

### 4.3 UIコンポーネント設計
- **Sidebar**: プロジェクト情報、保存ボタン、設定、ログアウト
- **TreeCanvas**: ツリー表示と操作（MVPではインデントリストでも可）
- **NodeCard**: ノード表示と編集
- **RelationBadge**: 関係ラベルの表示

### 4.4 キーボード操作の実装
- `Enter`: 編集確定 → 兄弟ノード追加
- `Tab`: 編集確定 → 子ノード追加
- `Shift+Enter`: 編集確定のみ
- `Esc`: 編集キャンセル
- `e.preventDefault()` でブラウザのデフォルト動作を防止

## 5. 実装の優先順位

### Phase 1: 基盤構築
1. プロジェクト構造の作成
2. Supabaseマイグレーションの作成
3. Go APIの基本構造（認証ミドルウェア、DB接続）

### Phase 2: 認証機能
1. Supabase認証設定
2. Googleログイン実装
3. JWT検証ミドルウェア

### Phase 3: プロジェクト管理
1. プロジェクト作成API
2. プロジェクト一覧API
3. プロジェクト詳細API

### Phase 4: ツリー編集機能
1. ツリー取得API
2. ノード追加API
3. ノード編集API
4. ノード削除API（子孫含む）

### Phase 5: UI実装
1. ログインページ
2. 目標入力ページ
3. メイン編集画面（最小限のUI）

### Phase 6: 統合とテスト
1. エラーハンドリング
2. バリデーション
3. 動作確認

## 6. 可読性・保守性を高める設計

### 6.1 ファイル分割の方針
- **API**: ハンドラー、サービス、リポジトリの3層構造
- **フロント**: ページ、コンポーネント、フック、ユーティリティに分割
- **型定義**: 各レイヤーで型を明確に定義

### 6.2 エラーハンドリング
- 共通エラーレスポンス形式
- エラーメッセージの国際化対応（将来拡張用）

### 6.3 テスト容易性
- 依存性注入を意識した設計
- モック可能なインターフェース定義

## 7. デプロイ構成の考慮

### 7.1 環境変数の管理
- `.env.local` (開発環境)
- `.env.example` (テンプレート)
- 本番環境は各プラットフォームの環境変数設定を使用

### 7.2 ビルドとデプロイ
- Next.js: `npm run build` → Cloudflare Pages / Vercel
- Go API: `go build` → Fly.io / Render / Railway

## 8. 今後の拡張性

### 8.1 AI機能の追加
- `/v1/projects/{id}/ai/suggest` エンドポイントの追加
- フロントエンドにAI提案UIの追加

### 8.2 テンプレート機能
- `templates` テーブルの追加
- テンプレート選択UIの追加

### 8.3 ドラッグ&ドロップ
- ツリーの可視化ライブラリの導入（react-d3-tree等）
- ドラッグ操作の実装
